# Design notebook for week ending April 10, 2016

## Last week's critique

I didn't really need detailed feedback per se, but I certainly took the advice to transition as quickly as possible from beefing up the back-end to working on the front-end. There were no major design changes as a result of the critique but that's not really because of the critique, it's just because I didn't really have any specific design decisions that I knew I'd need to make immediately. I also just generally had a good idea of where to go.

## Description

I did some work on codifying what a Modifications object should look like. Once I was satisfied with that, I moved on to figuring out how to do the syntax side. Josh Kutsko alerted me to parcon, a python parsing library that someone we know who took DSLs before us used. I spent a lot of my time just getting the IDE that I'm working in to recognize parcon, and then started playing with it to figure out how it works. I'm liking it so far; it's very simple and intuitive. It's essentially a well-written internal DSL.

One of the first things I did was write down a sort of mock-up of what the syntax might look like, and in doing so I realized something: that my files should have four sections, rather than three. The four sections are metadata, shape definitions, primitive animation definitions, and drawing rules. I think this will make for more ease of use by allowing users to re-use shapes that they've defined in multiple places. However I might need to change the back-end slightly. Not significantly I'm sure, but I might need to change the way that modifications are applied to shapes. Just a note to myself to keep in mind for later. I got the parsing working for the basic example I came up with (with some necessary modifications).

It's a very interesting experience coding based on an API that I specified, which is essentially what I'm doing in Translator. I have to remember all of the things that I've done, and it's sort of a double edged sword because of there's anything bad with the API, I'm the one who did those things but I have the power to fix them.

And after some work, I now have essentially a working prototype! I have a main.py file (which will be temporary more or less) with a function called render, and when I call that render function on a file of code in my new external language, it parses it, translates it into the language of ImageCreator, and then renders it! There's still tons of room for improvement, of course, and I more or less designed the syntax on a whim, so I'm not really glued to any of the decisions I made.

Another good idea just popped into my head for another feature: frame range restriction. Rendering 300 frames is painfully slow. So I should add a feature that restricts the range of frames that are generated. This would be super easy to implement and I suspect that for people using my project to make serious, long, intricate animations, they would likely want to make use of this feature. 

I have yet to hit a really massive hurdle in the process of making this language. I think I attribute this mostly to my having had a good model for how all of the parts of the system were going to interact in my head. I may not have written that model down before creating it, but I had all of the most important interactions figured out to the degree that when coding the intermediate representation, I had both how its pieces would need to interact and how those would be generated by the front-end syntax in mind. Because of that, neither of these were painstakingly hard to create.

I think the most difficult design decision I'm having to think about is how to let the user set the "recursion limit." Essentially these rules are going to be able to loop only a finite number of times, so I need to let the user specify how many times. But this is tricky because, for instance, what happens if the user specifies rule A which calls rule B which calls rule A, and rule A is supposed to have a recursion limit of 20 and rule B is supposed to have a limit of 10? Should this be an error, or should I let them? They're tricky decisions. I'm considering just having a global recursion limit. Another idea is to have it that when you specify a rule, you give that rule a limit, and that limit either gives the total number of times that that rule can be called, or the total number of times it can be called in one recursive chain (so an actual depth limit). I think I'm going to try implementing this latter method; it seems like what I would want if I were coding in this language. It will essentially give the number of times that you can call that rule in a single chain of calls. So if a rule calls only itself, that many calls to it will be made. If two rules call each other and have the same limit, they will each be called that many times, or if not the smaller limit will be used. But then I need to consider how that will interact with probability specification (i.e., can you specify two copies of the same rule with different limits? It wouldn't make sense so no). 

Another option is to add another section to the file template for limit specifications. I'm a little concerned that this would make them too complicated but not overly about this one because this would be optional, as you can just use the default for everything.

## Questions

**What is the most pressing issue for your project? What design decision do
you need to make, what implementation issue are you trying to solve, or how
are you evaluating your design and implementation?**

The most pressing issue is user experience. I essentially need people to try my language so I can see what new features I should have. The language is, more or less, working apart from some bells and whistles like formats and framerates. The core functionality is there. I need to know if what I've made is good from users, and what other core features might be useful. One idea from early testing with people is allowing elements/animation primitives to have multiple shapes per frame.

**What questions do you have for your critique partners? How can they best help
you?**

Really, I'd love if they could just take a look at the example programs I've written and see if they can write something they find interesting.

**How much time did you spend on the project this week? If you're working in a
team, how did you share the labor?**

I'm not really keeping strict track of time, but somewhere on the order of 8-10 hours?
